<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geo Spoofer Detector</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üìç</text></svg>">
    <script src="/thresholds-config.js"></script>
    <script src="/detection-runner.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
            min-height: 100vh;
            padding: 40px 20px;
            color: #fff;
            position: relative;
            overflow-y: auto;
            overflow-x: hidden;
        }

        /* Animated background particles */
        .particles {
            position: fixed;
            width: 100%;
            height: 100%;
            overflow: hidden;
            pointer-events: none;
            top: 0;
            left: 0;
        }

        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            animation: float 20s infinite linear;
        }

        @keyframes float {
            from {
                transform: translateY(100vh) translateX(0);
            }
            to {
                transform: translateY(-100px) translateX(100px);
            }
        }

        .container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 1200px;
            width: 90%;
            margin: 0 auto;
            z-index: 10;
            position: relative;
        }

        h1 {
            text-align: center;
            margin-bottom: 10px;
            font-size: 2em;
            background: linear-gradient(45deg, #fff, #a8c0ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .subtitle {
            text-align: center;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 30px;
        }

        .locate-btn {
            width: 100%;
            padding: 20px;
            font-size: 1.2em;
            font-weight: bold;
            background: linear-gradient(45deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            margin-bottom: 30px;
        }

        .locate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.5);
        }

        .locate-btn:active {
            transform: translateY(0);
        }

        .locate-btn.scanning {
            background: linear-gradient(45deg, #f093fb 0%, #f5576c 100%);
            pointer-events: none;
        }

        .ripple {
            position: absolute;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.5);
            transform: scale(0);
            animation: ripple 0.6s ease-out;
        }

        @keyframes ripple {
            to {
                transform: scale(4);
                opacity: 0;
            }
        }

        .results {
            display: none;
            animation: fadeIn 0.5s ease;
        }

        /* Two-column grid for result cards */
        .results-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
            align-items: start;
        }
        
        /* Constrain height for cards in grid */
        .results-grid .result-card {
            height: fit-content;
            max-height: 600px;
            display: flex;
            flex-direction: column;
        }
        
        /* Equal height for first row cards */
        .results-grid .result-card:nth-child(1),
        .results-grid .result-card:nth-child(2) {
            min-height: 350px;
        }
        
        .results-grid .detection-details {
            flex: 1;
            overflow-y: auto;
            max-height: 500px;
        }
        
        /* Adjust check category content height for the grid layout */
        .results-grid .check-category-content {
            min-height: 100px;
            max-height: 150px;
        }
        
        /* Responsive: Stack on smaller screens */
        @media (max-width: 1200px) {
            .results-grid {
                grid-template-columns: 1fr;
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .result-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        }

        /* Add scrolling to the all checks card */
        #allChecksDetails {
            max-height: none;
            overflow-y: visible;
            overflow-x: hidden;
            padding-right: 0;
        }

        /* Grid layout for check categories */
        .checks-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 15px;
        }
        
        /* Make categories look better in grid */
        .checks-grid .check-category {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 12px;
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.05);
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
        }
        
        .checks-grid .check-category:hover {
            background: rgba(255, 255, 255, 0.05);
            border-color: rgba(255, 255, 255, 0.1);
        }
        
        /* Adjust header in grid layout */
        .checks-grid .check-category h4 {
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        /* Make content scrollable within each category */
        .checks-grid .check-category-content {
            flex: 1;
            min-height: 150px;
            max-height: 250px;
            overflow-y: auto;
            overflow-x: hidden;
            padding-right: 5px;
        }
        
        /* Responsive grid for different screen sizes */
        @media (min-width: 1200px) {
            .checks-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }
        
        @media (max-width: 768px) {
            .checks-grid {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            /* Full width check categories on mobile */
            .result-card[style*="grid-column"] .checks-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Remove max-height from individual check details when in grid */
        .checks-grid #allChecksDetails {
            max-height: none;
            overflow: visible;
            padding-right: 0;
        }

        /* Add scrolling to location and environment details */
        #locationDetails,
        #environmentDetails {
            max-height: 400px;
            overflow-y: auto;
            overflow-x: hidden;
            padding-right: 10px;
        }

        /* Special handling for allChecksDetails in grid */
        .results-grid #allChecksDetails {
            overflow: visible;
            max-height: none;
        }

        /* Adjust the All Detection Checks card when it's full width */
        .result-card[style*="grid-column"] #allChecksDetails {
            max-height: 500px;
            overflow-y: auto;
            padding-right: 10px;
        }
        
        /* Ensure check categories work well in the full-width card */
        .result-card[style*="grid-column"] .checks-grid {
            grid-template-columns: repeat(3, 1fr);
        }
        
        /* Adjust check category content heights for bottom placement */
        .result-card[style*="grid-column"] .check-category-content {
            min-height: 150px;
            max-height: 250px;
        }

        /* Custom scrollbar styling */
        #allChecksDetails::-webkit-scrollbar,
        #locationDetails::-webkit-scrollbar,
        #environmentDetails::-webkit-scrollbar,
        .check-category-content::-webkit-scrollbar,
        .result-card[style*="grid-column"] #allChecksDetails::-webkit-scrollbar {
            width: 8px;
        }

        #allChecksDetails::-webkit-scrollbar-track,
        #locationDetails::-webkit-scrollbar-track,
        #environmentDetails::-webkit-scrollbar-track,
        .check-category-content::-webkit-scrollbar-track,
        .result-card[style*="grid-column"] #allChecksDetails::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        #allChecksDetails::-webkit-scrollbar-thumb,
        #locationDetails::-webkit-scrollbar-thumb,
        #environmentDetails::-webkit-scrollbar-thumb,
        .check-category-content::-webkit-scrollbar-thumb,
        .result-card[style*="grid-column"] #allChecksDetails::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
        }

        #allChecksDetails::-webkit-scrollbar-thumb:hover,
        #locationDetails::-webkit-scrollbar-thumb:hover,
        #environmentDetails::-webkit-scrollbar-thumb:hover,
        .check-category-content::-webkit-scrollbar-thumb:hover,
        .result-card[style*="grid-column"] #allChecksDetails::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .result-card::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            z-index: -1;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .result-card:hover::before {
            opacity: 1;
        }

        .result-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
        }

        .result-title {
            font-size: 1.1em;
            font-weight: bold;
        }

        .status-badge {
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: bold;
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }

        .status-authentic {
            background: rgba(52, 211, 153, 0.2);
            color: #34d399;
            border: 1px solid #34d399;
        }

        .status-suspicious {
            background: rgba(251, 191, 36, 0.2);
            color: #fbbf24;
            border: 1px solid #fbbf24;
        }

        .status-spoofed {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
            border: 1px solid #ef4444;
        }

        .detection-details {
            margin-top: 10px;
            padding-left: 20px;
        }

        .detection-item {
            margin: 12px 0;
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.8);
            display: flex;
            align-items: flex-start;
            gap: 8px;
            flex-direction: column;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .detection-item:last-child {
            border-bottom: none;
        }

        .detection-item > div:first-child {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 500;
        }

        .detection-explanation {
            margin-left: 28px;
            font-size: 0.85em;
            opacity: 0.8;
            margin-top: 4px;
            line-height: 1.5;
            color: rgba(255, 255, 255, 0.6);
            max-width: 95%;
        }

        .indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .indicator.pass {
            background: #34d399;
        }

        .indicator.warning {
            background: #fbbf24;
        }

        .indicator.fail {
            background: #ef4444;
        }

        .progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
            margin-bottom: 20px;
            display: none;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
        }

        .coordinates {
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.6);
            margin-top: 10px;
        }

        .check-category {
            margin-bottom: 0;
        }

        .check-category h4 {
            margin-bottom: 12px;
            color: rgba(255, 255, 255, 0.9);
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            user-select: none;
            transition: all 0.3s ease;
        }

        .check-category h4:hover {
            color: rgba(255, 255, 255, 1);
        }

        .check-category h4::before {
            content: '‚ñº';
            font-size: 0.8em;
            transition: transform 0.3s ease;
            display: inline-block;
        }

        .check-category.collapsed h4::before {
            transform: rotate(-90deg);
        }

        .category-summary {
            margin-left: auto;
            font-size: 0.85em;
            opacity: 0.7;
            display: none;
        }

        .check-category.collapsed .category-summary {
            display: inline-flex;
            gap: 8px;
        }

        .category-count {
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.8em;
        }

        .check-category-content {
            overflow: hidden;
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out;
            max-height: 500px;
            opacity: 1;
        }

        .check-category.collapsed .check-category-content {
            max-height: 0;
            opacity: 0;
        }
        
        /* In grid layout, ensure collapsed categories maintain their space */
        .checks-grid .check-category.collapsed {
            min-height: auto;
        }
        
        .checks-grid .check-category.collapsed h4 {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        .check-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 8px 0;
            padding: 6px 10px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 8px;
            font-size: 0.85em;
            transition: all 0.3s ease;
        }

        .check-item:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .check-status {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8em;
            flex-shrink: 0;
        }

        .check-status.pending {
            background: rgba(156, 163, 175, 0.2);
            color: #9ca3af;
        }

        .check-status.running {
            background: rgba(59, 130, 246, 0.2);
            color: #3b82f6;
            animation: pulse 2s infinite;
        }

        .check-status.pass {
            background: rgba(52, 211, 153, 0.2);
            color: #34d399;
        }

        .check-status.warning {
            background: rgba(251, 191, 36, 0.2);
            color: #fbbf24;
        }

        .check-status.fail {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .check-name {
            flex: 1;
            color: rgba(255, 255, 255, 0.8);
        }

        .check-result {
            font-size: 0.85em;
            color: rgba(255, 255, 255, 0.6);
        }

        /* Toggle all button */
        .toggle-all-btn {
            padding: 8px 16px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.85em;
            font-weight: 500;
            transition: all 0.3s ease;
        }
        
        .toggle-all-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }
        
        .toggle-all-btn.collapsed {
            background: linear-gradient(45deg, #94a3b8, #64748b);
        }
        
        /* Export button */
        .export-btn {
            padding: 8px 16px;
            background: linear-gradient(45deg, #10b981, #059669);
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.85em;
            font-weight: 500;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }
        
        .export-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 5px 15px rgba(16, 185, 129, 0.3);
        }
        
        .export-btn:active {
            transform: translateY(0);
        }
        
        .export-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-left: auto;
        }

        @media (max-width: 600px) {
            body {
                padding: 20px 10px;
            }
            
            .container {
                padding: 30px 20px;
            }
            
            h1 {
                font-size: 1.5em;
            }
            
            /* Stack result cards on mobile */
            .results-grid {
                grid-template-columns: 1fr;
            }
            
            /* Reduce padding on mobile */
            .result-card {
                padding: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="particles" id="particles"></div>
    
    <div class="container">
        <h1>Location Authenticity Detector</h1>
        <p class="subtitle">Verify genuine location & detect remote environments</p>
        
        <button class="locate-btn" id="locateBtn">
            <span id="btnText">üîç Locate Me</span>
        </button>
        
        <div style="display: flex; gap: 10px; margin-bottom: 20px;">
            <button class="locate-btn" id="exportSessionBtn" style="flex: 1; background: linear-gradient(45deg, #0891b2 0%, #06b6d4 100%); padding: 15px; font-size: 1em; display: none;">
                <span>üì• Export Sessions</span>
            </button>
        </div>
        
        <div class="progress-bar" id="progressBar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
        
        <div id="multiDetectionResults" style="display: none; margin-bottom: 20px;">
            <div class="result-card">
                <div class="result-header">
                    <span class="result-title">üîÑ Multiple Detection Analysis</span>
                    <span class="status-badge" id="consistencyStatus"></span>
                </div>
                <div class="detection-details" id="multiDetectionDetails"></div>
            </div>
        </div>
        
        <div class="results" id="results">
            <div class="results-grid">
                <div class="result-card">
                    <div class="result-header">
                        <span class="result-title">üìç Location Authenticity</span>
                        <span class="status-badge" id="locationStatus"></span>
                    </div>
                    <div class="detection-details" id="locationDetails"></div>
                    <div class="coordinates" id="coordinates"></div>
                </div>
                
                <div class="result-card">
                    <div class="result-header">
                        <span class="result-title">üíª Environment Type</span>
                        <span class="status-badge" id="environmentStatus"></span>
                    </div>
                    <div class="detection-details" id="environmentDetails"></div>
                </div>
                
                <div class="result-card" style="grid-column: 1 / -1;">
                    <div class="result-header">
                        <span class="result-title">üîç All Detection Checks</span>
                        <span class="status-badge" id="overallStatus"></span>
                    </div>
                    <div class="detection-details" id="allChecksDetails">
                        <div style="margin-bottom: 15px;">
                            <button id="toggleAllCategories" class="toggle-all-btn">Collapse All</button>
                        </div>
                        <div class="checks-grid">
                            <div class="check-category" id="locationCategory">
                                <h4>üìç Location Verification</h4>
                                <div class="check-category-content">
                                    <div id="locationChecks"></div>
                                </div>
                            </div>
                            <div class="check-category" id="environmentCategory">
                                <h4>üíª Environment Analysis</h4>
                                <div class="check-category-content">
                                    <div id="environmentChecks"></div>
                                </div>
                            </div>
                            <div class="check-category" id="networkCategory">
                                <h4>üåê Network & Browser</h4>
                                <div class="check-category-content">
                                    <div id="networkChecks"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="result-card" style="grid-column: 1 / -1; display: none;" id="patternAnalysisCard">
                    <div class="result-header">
                        <span class="result-title">üî¨ Pattern Analysis</span>
                        <div style="display: flex; gap: 10px;">
                            <button class="toggle-all-btn" id="runLiteAnalysis" style="background: linear-gradient(45deg, #059669, #10b981);">Lite Analysis</button>
                            <button class="toggle-all-btn" id="runPatternAnalysis">Full Analysis</button>
                        </div>
                    </div>
                    <div class="detection-details" id="patternAnalysisDetails">
                        <div id="patternAnalysisContent">
                            <p style="text-align: center; opacity: 0.7;">Choose analysis type: <strong>Lite</strong> for quick results or <strong>Full</strong> for comprehensive AI evaluation</p>
                        </div>
                    </div>
                </div>
                
                <div class="result-card" style="grid-column: 1 / -1; display: none;" id="rulesCheckCard">
                    <div class="result-header">
                        <span class="result-title">üìã Rule-Based Checks</span>
                        <span class="status-badge" id="rulesCheckStatus"></span>
                    </div>
                    <div class="detection-details" id="rulesCheckDetails">
                        <div id="rulesCheckContent">
                            <p style="text-align: center; opacity: 0.7;">Running rule-based validation checks...</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Configuration -->
    <script src="/config.js"></script>
    
    <!-- Include API integration first -->
    <script src="/api-integration.js"></script>
    
    <!-- Session Rules Check -->
    <script src="/session-rules-check.js"></script>
    
    <script>
        console.log('Main script starting...');
        console.log('USE_API:', typeof USE_API !== 'undefined' ? USE_API : 'undefined');
        
        // Create animated particles
        function createParticles() {
            const particlesContainer = document.getElementById('particles');
            for (let i = 0; i < 50; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 20 + 's';
                particle.style.animationDuration = (20 + Math.random() * 10) + 's';
                particlesContainer.appendChild(particle);
            }
        }
        createParticles();

        // Configuration for production
        const CONFIG = {
            DEBUG_MODE: window.location.hostname === 'localhost',
            DETECTION_METHODS: {
                WEBRTC_CHECK: true,
                DNS_TIMING_CHECK: false, // Disabled in production
                NAVIGATOR_PROPERTIES_CHECK: true,
                TIMEZONE_CHECK: true
            },
            log: function(...args) {
                if (this.DEBUG_MODE) {
                    console.log(...args);
                }
            }
        };

        // Detection state
        let detectionState = {
            location: null,
            timestamps: [],
            permissions: {},
            environmentFlags: [],
            locationFlags: []
        };

        // Global session data for export
        let sessionData = null;

        // Comprehensive check list
        const allChecks = {
            location: [
                { id: 'geo-api', name: 'Geolocation API Available', status: 'pending', result: '' },
                { id: 'geo-permission', name: 'Location Permission', status: 'pending', result: '' },
                { id: 'response-time', name: 'GPS Response Time', status: 'pending', result: '' },
                { id: 'accuracy', name: 'Location Accuracy', status: 'pending', result: '' },
                { id: 'null-island', name: 'Null Island Check', status: 'pending', result: '' },
                { id: 'round-coords', name: 'Coordinate Precision', status: 'pending', result: '' },
                { id: 'vpn-detection', name: 'VPN/Proxy Detection', status: 'pending', result: '' }
            ],
            environment: [
                { id: 'touch-support', name: 'Touch Event Consistency', status: 'pending', result: '' },
                { id: 'screen-ratio', name: 'Screen Aspect Ratio', status: 'pending', result: '' },
                { id: 'color-depth', name: 'Display Color Depth', status: 'pending', result: '' },
                { id: 'gpu-check', name: 'Graphics Adapter', status: 'pending', result: '' },
                { id: 'input-timing', name: 'Input Device Timing', status: 'pending', result: '' },
                { id: 'time-flow', name: 'System Time Consistency', status: 'pending', result: '' }
            ],
            network: [
                { id: 'webrtc-ip', name: 'WebRTC IP Detection', status: 'pending', result: '' },
                { id: 'multiple-ips', name: 'Multiple IP Check', status: 'pending', result: '' },
                { id: 'navigator-props', name: 'Browser Properties', status: 'pending', result: '' },
                { id: 'dns-timing', name: 'DNS Resolution Timing', status: 'pending', result: '' },
                { id: 'timezone', name: 'Timezone Consistency', status: 'pending', result: '' }
            ]
        };

        // Helper function to update check status
        function updateCheck(category, checkId, status, result = '') {
            const check = allChecks[category].find(c => c.id === checkId);
            if (check) {
                check.status = status;
                check.result = result;
                renderChecks();
            }
        }
        
        // Make updateCheck globally available for API integration
        window.updateCheck = updateCheck;

        // Render all checks
        function renderChecks() {
            const locationChecksEl = document.getElementById('locationChecks');
            const environmentChecksEl = document.getElementById('environmentChecks');
            const networkChecksEl = document.getElementById('networkChecks');
            
            // Clear existing content
            locationChecksEl.innerHTML = '';
            environmentChecksEl.innerHTML = '';
            networkChecksEl.innerHTML = '';
            
            // Render each category
            renderCheckCategory(allChecks.location, locationChecksEl);
            renderCheckCategory(allChecks.environment, environmentChecksEl);
            renderCheckCategory(allChecks.network, networkChecksEl);
            
            // Update overall status
            updateOverallStatus();
        }

        function renderCheckCategory(checks, container) {
            checks.forEach(check => {
                const checkItem = document.createElement('div');
                checkItem.className = 'check-item';
                
                const statusIcon = getStatusIcon(check.status);
                
                checkItem.innerHTML = `
                    <div class="check-status ${check.status}">${statusIcon}</div>
                    <div class="check-name">${check.name}</div>
                    <div class="check-result">${check.result}</div>
                `;
                
                container.appendChild(checkItem);
            });
        }

        function getStatusIcon(status) {
            switch(status) {
                case 'pending': return '‚óã';
                case 'running': return '‚óê';
                case 'pass': return '‚úì';
                case 'warning': return '!';
                case 'fail': return '‚úó';
                default: return '?';
            }
        }

        function updateOverallStatus() {
            const allChecksList = [...allChecks.location, ...allChecks.environment, ...allChecks.network];
            const failCount = allChecksList.filter(c => c.status === 'fail').length;
            const warningCount = allChecksList.filter(c => c.status === 'warning').length;
            const passCount = allChecksList.filter(c => c.status === 'pass').length;
            const totalChecks = allChecksList.length;
            
            const overallStatusEl = document.getElementById('overallStatus');
            
            if (failCount > 0) {
                overallStatusEl.textContent = `${failCount} Failed`;
                overallStatusEl.className = 'status-badge status-spoofed';
            } else if (warningCount > 0) {
                overallStatusEl.textContent = `${warningCount} Warnings`;
                overallStatusEl.className = 'status-badge status-suspicious';
            } else if (passCount === totalChecks) {
                overallStatusEl.textContent = 'All Passed';
                overallStatusEl.className = 'status-badge status-authentic';
            } else {
                overallStatusEl.textContent = 'Checking...';
                overallStatusEl.className = 'status-badge status-suspicious';
            }
            
            // Update category summaries
            updateCategorySummary('location', allChecks.location);
            updateCategorySummary('environment', allChecks.environment);
            updateCategorySummary('network', allChecks.network);
        }
        
        function updateCategorySummary(categoryName, checks) {
            const categoryEl = document.getElementById(`${categoryName}Category`);
            if (!categoryEl) return;
            
            const header = categoryEl.querySelector('h4');
            
            // Remove existing summary if any
            const existingSummary = header.querySelector('.category-summary');
            if (existingSummary) {
                existingSummary.remove();
            }
            
            // Calculate counts
            const failCount = checks.filter(c => c.status === 'fail').length;
            const warningCount = checks.filter(c => c.status === 'warning').length;
            const passCount = checks.filter(c => c.status === 'pass').length;
            const totalCount = checks.length;
            
            // Create summary element
            const summary = document.createElement('span');
            summary.className = 'category-summary';
            
            if (failCount > 0) {
                summary.innerHTML += `<span class="category-count" style="background: rgba(239, 68, 68, 0.2); color: #ef4444;">${failCount} failed</span>`;
            }
            if (warningCount > 0) {
                summary.innerHTML += `<span class="category-count" style="background: rgba(251, 191, 36, 0.2); color: #fbbf24;">${warningCount} warning${warningCount > 1 ? 's' : ''}</span>`;
            }
            if (passCount === totalCount && totalCount > 0) {
                summary.innerHTML += `<span class="category-count" style="background: rgba(52, 211, 153, 0.2); color: #34d399;">All passed</span>`;
            }
            
            header.appendChild(summary);
        }

        // Make detectionState globally available for API integration
        window.detectionState = detectionState;

        // Main detection function
        async function startDetection() {
            const btn = document.getElementById('locateBtn');
            const btnText = document.getElementById('btnText');
            const progressBar = document.getElementById('progressBar');
            const progressFill = document.getElementById('progressFill');
            const results = document.getElementById('results');
            
            // Reset state
            detectionState = {
                location: null,
                timestamps: [],
                permissions: {},
                environmentFlags: [],
                locationFlags: []
            };
            
            // Reset all checks
            Object.keys(allChecks).forEach(category => {
                allChecks[category].forEach(check => {
                    check.status = 'pending';
                    check.result = '';
                });
            });
            
            // Also update window.detectionState
            window.detectionState = detectionState;
            
            // Update UI
            btn.classList.add('scanning');
            btnText.textContent = 'üîÑ Scanning...';
            progressBar.style.display = 'block';
            results.style.display = 'block'; // Show results immediately
            
            // Initial render of all checks
            renderChecks();
            
            // Run detection phases
            await updateProgress(10);
            await detectEnvironment();
            
            await updateProgress(30);
            await detectPermissions();
            
            await updateProgress(50);
            await detectLocation();
            
            await updateProgress(70);
            await detectTimingAnomalies();
            
            await updateProgress(90);
            await detectBrowserInconsistencies();
            
            const detectionCount = 3;
            const delay = 1000;
            const session = await window.DetectionRunner.runSessionWithMultipleDetections(
                detectionCount, 
                delay, 
                {
                    includeLocation: true,
                    includeEnvironment: true,
                    includeNetwork: true,
                    silent: false,
                    metadata: {
                        purpose: 'multi-detection-consistency-check',
                        userAgent: navigator.userAgent
                    }
                }
            );
            console.log('session', session);
            
            // Store session data globally for export
            sessionData = session;
            
            await updateProgress(100);
            
            // Analyze results
            analyzeResults();
            
            // Run rule-based checks
            runRulesCheck();
            
            // Show results
            setTimeout(() => {
                btn.classList.remove('scanning');
                btnText.textContent = 'üîç Locate Me';
                progressBar.style.display = 'none';
                progressFill.style.width = '0%';
                
                // Show export button
                document.getElementById('exportSessionBtn').style.display = 'block';
            }, 500);
        }

        // Progress animation
        function updateProgress(percent) {
            return new Promise(resolve => {
                document.getElementById('progressFill').style.width = percent + '%';
                setTimeout(resolve, 300);
            });
        }

        // Environment detection
        async function detectEnvironment() {
            // Check for RDP/VNC indicators
            updateCheck('environment', 'touch-support', 'running');
            if (navigator.maxTouchPoints === 0 && 'ontouchstart' in window) {
                detectionState.environmentFlags.push({
                    type: 'warning',
                    message: 'Touch events without touch support',
                    explanation: 'The browser reports touch event capabilities but no touch points are detected. This often indicates remote desktop software that passes through touch events from the host system.'
                });
                updateCheck('environment', 'touch-support', 'warning', 'No touch points');
            } else {
                updateCheck('environment', 'touch-support', 'pass', 'Consistent');
            }
            
            // Check screen resolution patterns
            updateCheck('environment', 'screen-ratio', 'running');
            const screenRatio = window.screen.width / window.screen.height;
            const windowRatio = window.innerWidth / window.innerHeight;
            const commonRatios = [16/9, 16/10, 4/3, 21/9, 3/2, 5/4, 5/3];
            
            // Use window ratio instead of screen ratio for browser windows
            const ratioToCheck = windowRatio;
            const isCommonRatio = commonRatios.some(ratio => 
                Math.abs(ratioToCheck - ratio) < 0.1  // Increased threshold for browser windows
            );
            
            // Only flag if ratio is very unusual (too tall or too wide)
            const isVeryUnusual = ratioToCheck < 0.5 || ratioToCheck > 3.0;
            
            if (isVeryUnusual) {
                detectionState.environmentFlags.push({
                    type: 'warning',
                    message: 'Unusual window aspect ratio',
                    explanation: `Detected window ratio: ${ratioToCheck.toFixed(2)}. This very unusual aspect ratio (${ratioToCheck < 0.5 ? 'extremely tall' : 'extremely wide'}) may indicate a remote desktop session or unusual display configuration.`
                });
                updateCheck('environment', 'screen-ratio', 'warning', `${ratioToCheck.toFixed(2)}`);
            } else if (!isCommonRatio && Math.abs(screenRatio - windowRatio) > 0.3) {
                // Check if window ratio differs significantly from screen ratio
                detectionState.environmentFlags.push({
                    type: 'warning',
                    message: 'Window size mismatch',
                    explanation: `Window ratio (${windowRatio.toFixed(2)}) differs significantly from screen ratio (${screenRatio.toFixed(2)}). This might indicate a remote desktop window or virtualized environment.`
                });
                updateCheck('environment', 'screen-ratio', 'warning', `Win: ${windowRatio.toFixed(2)}`);
            } else {
                updateCheck('environment', 'screen-ratio', 'pass', `${ratioToCheck.toFixed(2)}`);
            }
            
            // Check color depth
            updateCheck('environment', 'color-depth', 'running');
            if (window.screen.colorDepth < 24) {
                detectionState.environmentFlags.push({
                    type: 'warning',
                    message: 'Low color depth (possible RDP)',
                    explanation: `Color depth: ${window.screen.colorDepth}-bit. Modern displays use 24-bit or higher. Lower values often indicate remote desktop connections optimizing for bandwidth.`
                });
                updateCheck('environment', 'color-depth', 'warning', `${window.screen.colorDepth}-bit`);
            } else {
                updateCheck('environment', 'color-depth', 'pass', `${window.screen.colorDepth}-bit`);
            }
            
            // Check for virtual display drivers
            updateCheck('environment', 'gpu-check', 'running');
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                if (gl) {
                    const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                    if (debugInfo) {
                        const renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                        if (renderer.includes('VMware') || renderer.includes('VirtualBox') || 
                            renderer.includes('Microsoft Basic Render') || renderer.includes('llvmpipe')) {
                            detectionState.environmentFlags.push({
                                type: 'fail',
                                message: 'Virtual display adapter detected',
                                explanation: `GPU: ${renderer}. This is a virtual graphics adapter used by virtual machines, not a physical GPU.`
                            });
                            updateCheck('environment', 'gpu-check', 'fail', 'Virtual GPU');
                        } else {
                            updateCheck('environment', 'gpu-check', 'pass', 'Physical GPU');
                        }
                    } else {
                        updateCheck('environment', 'gpu-check', 'pass', 'Unknown');
                    }
                }
            } catch (e) {
                updateCheck('environment', 'gpu-check', 'pass', 'Unable to check');
            }
            
            // Check keyboard/mouse latency patterns
            updateCheck('environment', 'input-timing', 'running');
            let lastEventTime = 0;
            let syntheticDetected = false;
            const checkLatency = (e) => {
                const now = performance.now();
                if (lastEventTime && (now - lastEventTime) < 1) {
                    detectionState.environmentFlags.push({
                        type: 'warning',
                        message: 'Synthetic input detected',
                        explanation: 'Mouse or keyboard events are occurring faster than humanly possible (<1ms apart). This suggests automated input or remote desktop software.'
                    });
                    syntheticDetected = true;
                    updateCheck('environment', 'input-timing', 'warning', 'Too fast');
                }
                lastEventTime = now;
            };
            
            // Monitor for a brief period
            document.addEventListener('mousemove', checkLatency);
            setTimeout(() => {
                document.removeEventListener('mousemove', checkLatency);
                if (!syntheticDetected) {
                    updateCheck('environment', 'input-timing', 'pass', 'Normal');
                }
            }, 1000);
        }

        // Make function available globally for API integration
        window.detectEnvironment = detectEnvironment;

        // Permission detection
        async function detectPermissions() {
            // Check geolocation permission
            updateCheck('location', 'geo-permission', 'running');
            try {
                const permissionStatus = await navigator.permissions.query({ name: 'geolocation' });
                detectionState.permissions.geolocation = permissionStatus.state;
                
                if (permissionStatus.state === 'denied') {
                    detectionState.locationFlags.push({
                        type: 'fail',
                        message: 'Geolocation permission denied',
                        explanation: 'Location access was explicitly denied. This prevents GPS-based verification. You can change this in your browser settings if you want to enable location detection.'
                    });
                    updateCheck('location', 'geo-permission', 'fail', 'Denied');
                } else if (permissionStatus.state === 'granted') {
                    updateCheck('location', 'geo-permission', 'pass', 'Granted');
                } else {
                    updateCheck('location', 'geo-permission', 'warning', 'Prompt required');
                }
            } catch (e) {
                detectionState.permissions.geolocation = 'unknown';
                updateCheck('location', 'geo-permission', 'pass', 'Unknown');
            }
        }

        // Location detection with multiple verification steps
        async function detectLocation() {
            updateCheck('location', 'geo-api', 'running');
            if (!navigator.geolocation) {
                detectionState.locationFlags.push({
                    type: 'fail',
                    message: 'Geolocation API not available',
                    explanation: 'Your browser does not support the Geolocation API. This may be an older browser or one with location services disabled at the system level.'
                });
                updateCheck('location', 'geo-api', 'fail', 'Not available');
                updateCheck('location', 'response-time', 'fail', 'N/A');
                updateCheck('location', 'accuracy', 'fail', 'N/A');
                updateCheck('location', 'null-island', 'fail', 'N/A');
                updateCheck('location', 'round-coords', 'fail', 'N/A');
                return;
            }
            
            updateCheck('location', 'geo-api', 'pass', 'Available');
            
            return new Promise((resolve) => {
                const startTime = performance.now();
                
                navigator.geolocation.getCurrentPosition(
                    async (position) => {
                        const endTime = performance.now();
                        const duration = endTime - startTime;
                        
                        detectionState.location = {
                            latitude: position.coords.latitude,
                            longitude: position.coords.longitude,
                            accuracy: position.coords.accuracy,
                            timestamp: position.timestamp
                        };
                        
                        const thresholds = window.ThresholdsConfig.getThresholdsSync();
                        
                        // Check for suspiciously fast response
                        updateCheck('location', 'response-time', 'running');
                        if (duration < thresholds.location.responseTime.suspicious) {
                            detectionState.locationFlags.push({
                                type: 'warning',
                                message: 'Location obtained suspiciously fast',
                                explanation: `Response time: ${duration.toFixed(1)}ms. Real GPS typically takes 100-1000ms. Very fast responses may indicate a location spoofing extension providing cached/fake coordinates.`
                            });
                            updateCheck('location', 'response-time', 'warning', `${duration.toFixed(0)}ms`);
                        } else {
                            updateCheck('location', 'response-time', 'pass', `${duration.toFixed(0)}ms`);
                        }
                        
                        // Check accuracy
                        updateCheck('location', 'accuracy', 'running');
                        if (position.coords.accuracy > thresholds.location.accuracy.low) {
                            detectionState.locationFlags.push({
                                type: 'warning',
                                message: 'Low location accuracy',
                                explanation: `Accuracy: ¬±${Math.round(position.coords.accuracy)}m. GPS typically provides 5-10m accuracy. High values suggest IP-based geolocation or poor GPS signal.`
                            });
                            updateCheck('location', 'accuracy', 'warning', `¬±${Math.round(position.coords.accuracy)}m`);
                        } else {
                            updateCheck('location', 'accuracy', 'pass', `¬±${Math.round(position.coords.accuracy)}m`);
                        }
                        
                        // Check for common spoofing coordinates
                        const lat = position.coords.latitude;
                        const lon = position.coords.longitude;
                        
                        updateCheck('location', 'null-island', 'running');
                        if (lat === 0 && lon === 0) {
                            detectionState.locationFlags.push({
                                type: 'fail',
                                message: 'Null Island coordinates detected',
                                explanation: 'Coordinates (0¬∞, 0¬∞) point to "Null Island" in the Atlantic Ocean. This is a common default value used by spoofing tools.'
                            });
                            updateCheck('location', 'null-island', 'fail', 'Detected');
                        } else {
                            updateCheck('location', 'null-island', 'pass', 'Valid coords');
                        }
                        
                        // Check for overly round numbers
                        updateCheck('location', 'round-coords', 'running');
                        if (lat % 1 === 0 && lon % 1 === 0) {
                            detectionState.locationFlags.push({
                                type: 'warning',
                                message: 'Suspiciously round coordinates',
                                explanation: `Coordinates are exact integers (${lat}¬∞, ${lon}¬∞). Real GPS coordinates typically have decimal precision. Round numbers suggest manual input or basic spoofing.`
                            });
                            updateCheck('location', 'round-coords', 'warning', 'Too round');
                        } else {
                            updateCheck('location', 'round-coords', 'pass', 'Normal precision');
                        }
                        
                        // Check VPN if API is available
                        if (typeof USE_API !== 'undefined' && USE_API) {
                            updateCheck('location', 'vpn-detection', 'running');
                            try {
                                const vpnResponse = await fetch('/api/vpn/check');
                                const vpnData = await vpnResponse.json();
                                
                                if (vpnData.isVPN) {
                                    detectionState.locationFlags.push({
                                        type: 'warning',
                                        message: 'VPN/Proxy detected',
                                        explanation: vpnData.explanation
                                    });
                                    updateCheck('location', 'vpn-detection', 'warning', `${vpnData.confidence}% confidence`);
                                } else {
                                    updateCheck('location', 'vpn-detection', 'pass', 'No VPN');
                                }
                            } catch (e) {
                                updateCheck('location', 'vpn-detection', 'pass', 'Unable to check');
                            }
                        } else {
                            updateCheck('location', 'vpn-detection', 'pass', 'API not available');
                        }
                        
                        resolve();
                    },
                    (error) => {
                        let explanation = '';
                        switch(error.code) {
                            case 1: // PERMISSION_DENIED
                                explanation = 'Location access was denied. Check your browser settings to allow location access for this site.';
                                break;
                            case 2: // POSITION_UNAVAILABLE
                                explanation = 'Unable to determine location. This can happen when GPS/WiFi positioning is unavailable or disabled.';
                                break;
                            case 3: // TIMEOUT
                                explanation = 'Location request timed out. This might indicate poor GPS signal or network issues.';
                                break;
                            default:
                                explanation = 'An unknown error occurred while trying to get your location.';
                        }
                        
                        detectionState.locationFlags.push({
                            type: 'fail',
                            message: `Location error: ${error.message}`,
                            explanation: explanation
                        });
                        
                        updateCheck('location', 'response-time', 'fail', 'Error');
                        updateCheck('location', 'accuracy', 'fail', 'Error');
                        updateCheck('location', 'null-island', 'fail', 'Error');
                        updateCheck('location', 'round-coords', 'fail', 'Error');
                        updateCheck('location', 'vpn-detection', 'fail', 'Error');
                        
                        resolve();
                    },
                    {
                        enableHighAccuracy: true,
                        timeout: 10000,
                        maximumAge: 0
                    }
                );
            });
        }

        // Make function available globally for API integration
        window.detectLocation = detectLocation;

        // Timing anomaly detection
        async function detectTimingAnomalies() {
            updateCheck('environment', 'time-flow', 'running');
            
            // Check system time consistency
            const jsTime = Date.now();
            const perfTime = performance.now();
            
            // Multiple timestamp collection
            for (let i = 0; i < 5; i++) {
                detectionState.timestamps.push({
                    js: Date.now(),
                    perf: performance.now()
                });
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            // Check for time manipulation
            let irregularities = 0;
            for (let i = 1; i < detectionState.timestamps.length; i++) {
                const jsDiff = detectionState.timestamps[i].js - detectionState.timestamps[i-1].js;
                const perfDiff = detectionState.timestamps[i].perf - detectionState.timestamps[i-1].perf;
                
                if (Math.abs(jsDiff - perfDiff) > 10) {
                    irregularities++;
                }
            }
            
            if (irregularities > 2) {
                detectionState.environmentFlags.push({
                    type: 'warning',
                    message: 'Time flow irregularities detected',
                    explanation: `Found ${irregularities} timing inconsistencies between JavaScript Date and Performance timers. This may indicate time manipulation or virtualization overhead affecting system timing.`
                });
                updateCheck('environment', 'time-flow', 'warning', `${irregularities} anomalies`);
            } else {
                updateCheck('environment', 'time-flow', 'pass', 'Consistent');
            }
        }

        // Browser consistency checks
        async function detectBrowserInconsistencies() {
            // Check for browser extension artifacts
            try {
                // Method 1: Check for modified navigator properties (common with VPN extensions)
                if (CONFIG.DETECTION_METHODS.NAVIGATOR_PROPERTIES_CHECK) {
                    updateCheck('network', 'navigator-props', 'running');
                    const suspiciousProperties = ['brave', 'globalPrivacyControl'];
                    let foundProps = [];
                    
                    suspiciousProperties.forEach(prop => {
                        if (prop in navigator) {
                            detectionState.locationFlags.push({
                                type: 'warning',
                                message: `Detected ${prop} property (possible privacy extension)`,
                                explanation: `The navigator.${prop} property is present. This is added by privacy-focused browsers or extensions and may affect location accuracy.`
                            });
                            foundProps.push(prop);
                        }
                    });
                    
                    if (foundProps.length > 0) {
                        updateCheck('network', 'navigator-props', 'warning', foundProps.join(', '));
                    } else {
                        updateCheck('network', 'navigator-props', 'pass', 'Standard');
                    }
                }
                
                // Method 2: Check WebRTC for real IP vs VPN IP
                if (CONFIG.DETECTION_METHODS.WEBRTC_CHECK) {
                    updateCheck('network', 'webrtc-ip', 'running');
                    let hasPrivateIp = false;
                    try {
                        const pc = new RTCPeerConnection({
                            iceServers: [{urls: 'stun:stun.l.google.com:19302'}]
                        });
                        
                        pc.createDataChannel('');
                        const offer = await pc.createOffer();
                        await pc.setLocalDescription(offer);
                        
                        // Set up promise to collect all IPs
                        const ips = await new Promise((resolve) => {
                            const collectedIps = new Set();
                            let timeout = setTimeout(() => {
                                pc.close();
                                resolve(Array.from(collectedIps));
                            }, 2000); // 2 second timeout
                            
                            pc.onicecandidate = (ice) => {
                                if (!ice || !ice.candidate || !ice.candidate.candidate) return;
                                
                                const candidate = ice.candidate.candidate;
                                const ipRegex = /([0-9]{1,3}\.){3}[0-9]{1,3}/g;
                                const matches = candidate.match(ipRegex);
                                
                                if (matches) {
                                    matches.forEach(ip => {
                                        collectedIps.add(ip);
                                        
                                        // Check for VPN/proxy indicators
                                        if (ip.startsWith('10.') || ip.startsWith('172.') || ip.startsWith('192.168.')) {
                                            detectionState.locationFlags.push({
                                                type: 'warning',
                                                message: 'Private IP detected (possible VPN)',
                                                explanation: `WebRTC revealed private IP: ${ip}. This is a local network address that may indicate VPN usage, as VPNs often create virtual network adapters with private IPs.`
                                            });
                                            hasPrivateIp = true;
                                        }
                                    });
                                }
                            };
                        });
                        
                        if (hasPrivateIp) {
                            updateCheck('network', 'webrtc-ip', 'warning', 'Private IPs found');
                        } else if (ips.length > 0) {
                            updateCheck('network', 'webrtc-ip', 'pass', `${ips.length} IPs found`);
                        } else {
                            updateCheck('network', 'webrtc-ip', 'pass', 'No IPs leaked');
                        }
                        
                        // Check for multiple public IPs (VPN indicator)
                        updateCheck('network', 'multiple-ips', 'running');
                        const publicIps = ips.filter(ip => 
                            !ip.startsWith('10.') && 
                            !ip.startsWith('172.') && 
                            !ip.startsWith('192.168.') &&
                            !ip.startsWith('127.')
                        );
                        
                        if (publicIps.length > 1) {
                            detectionState.locationFlags.push({
                                type: 'warning',
                                message: 'Multiple public IPs detected (possible VPN)',
                                explanation: `Found ${publicIps.length} public IPs: ${publicIps.join(', ')}. Multiple public IPs often indicate VPN or proxy usage, as traffic may be routed through different exit points.`
                            });
                            updateCheck('network', 'multiple-ips', 'warning', `${publicIps.length} public IPs`);
                        } else {
                            updateCheck('network', 'multiple-ips', 'pass', `${publicIps.length} public IP`);
                        }
                    } catch (e) {
                        // WebRTC might be disabled
                        CONFIG.log('WebRTC detection skipped:', e.message);
                        updateCheck('network', 'webrtc-ip', 'pass', 'WebRTC disabled');
                        updateCheck('network', 'multiple-ips', 'pass', 'WebRTC disabled');
                    }
                } else {
                    updateCheck('network', 'webrtc-ip', 'pass', 'Check disabled');
                    updateCheck('network', 'multiple-ips', 'pass', 'Check disabled');
                }
                
                // Method 3: Check for DNS leaks via timing
                if (CONFIG.DETECTION_METHODS.DNS_TIMING_CHECK) {
                    updateCheck('network', 'dns-timing', 'running');
                    try {
                        const dnsTestDomains = [
                            'dns-leak-test-' + Math.random().toString(36).substr(2, 9) + '.com'
                        ];
                        
                        let suspiciousTiming = false;
                        for (const domain of dnsTestDomains) {
                            const startTime = performance.now();
                            try {
                                // This will fail but we're measuring timing
                                await fetch(`https://${domain}`, { 
                                    mode: 'no-cors',
                                    cache: 'no-cache'
                                }).catch(() => {}); // Silently catch the expected error
                            } catch (e) {
                                // Expected to fail
                            }
                            const endTime = performance.now();
                            const dnsTime = endTime - startTime;
                            
                            // Suspiciously fast DNS resolution might indicate local VPN DNS
                            if (dnsTime < 5) {
                                detectionState.environmentFlags.push({
                                    type: 'warning',
                                    message: 'Unusual DNS resolution timing',
                                    explanation: `DNS lookup completed in ${dnsTime.toFixed(1)}ms. Extremely fast DNS resolution (<5ms) may indicate a local DNS cache or VPN software intercepting DNS queries.`
                                });
                                suspiciousTiming = true;
                                updateCheck('network', 'dns-timing', 'warning', `${dnsTime.toFixed(0)}ms`);
                            }
                        }
                        
                        if (!suspiciousTiming) {
                            updateCheck('network', 'dns-timing', 'pass', 'Normal');
                        }
                    } catch (e) {
                        CONFIG.log('DNS timing check skipped:', e.message);
                        updateCheck('network', 'dns-timing', 'pass', 'Unable to check');
                    }
                } else {
                    updateCheck('network', 'dns-timing', 'pass', 'Check disabled');
                }
                
                // Method 4: Check timezone consistency
                if (CONFIG.DETECTION_METHODS.TIMEZONE_CHECK) {
                    updateCheck('network', 'timezone', 'running');
                    const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
                    if (detectionState.location) {
                        // This is a simplified check - in production, you'd use a timezone API
                        const expectedOffset = new Date().getTimezoneOffset();
                        updateCheck('network', 'timezone', 'pass', timezone);
                    } else {
                        updateCheck('network', 'timezone', 'pass', timezone);
                    }
                } else {
                    updateCheck('network', 'timezone', 'pass', 'Check disabled');
                }
            } catch (e) {
                CONFIG.log('Browser consistency check error:', e);
            }
        }

        // Analyze all collected data
        function analyzeResults() {
            const locationDetails = document.getElementById('locationDetails');
            const environmentDetails = document.getElementById('environmentDetails');
            const locationStatus = document.getElementById('locationStatus');
            const environmentStatus = document.getElementById('environmentStatus');
            const coordinates = document.getElementById('coordinates');
            
            const thresholds = window.ThresholdsConfig.getThresholdsSync();
            
            // Clear previous results
            locationDetails.innerHTML = '';
            environmentDetails.innerHTML = '';
            
            // Analyze location authenticity
            let locationScore = 100;
            let locationStatusText = 'Authentic';
            let locationStatusClass = 'status-authentic';
            
            detectionState.locationFlags.forEach(flag => {
                const item = document.createElement('div');
                item.className = 'detection-item';
                
                // Create main message with indicator
                const mainLine = document.createElement('div');
                mainLine.innerHTML = `<span class="indicator ${flag.type}"></span>${flag.message}`;
                item.appendChild(mainLine);
                
                // Add explanation if available
                if (flag.explanation) {
                    const explanation = document.createElement('div');
                    explanation.className = 'detection-explanation';
                    explanation.textContent = flag.explanation;
                    item.appendChild(explanation);
                }
                
                locationDetails.appendChild(item);
                
                if (flag.type === 'warning') locationScore -= thresholds.scoring.deductions.locationWarning;
                if (flag.type === 'fail') locationScore -= thresholds.scoring.deductions.locationFail;
            });
            
            if (locationScore < thresholds.location.score.likelySpoofed) {
                locationStatusText = 'Likely Spoofed';
                locationStatusClass = 'status-spoofed';
            } else if (locationScore < thresholds.location.score.suspicious) {
                locationStatusText = 'Suspicious';
                locationStatusClass = 'status-suspicious';
            }
            
            if (!detectionState.location) {
                locationStatusText = 'Unable to Verify';
                locationStatusClass = 'status-spoofed';
            }
            
            locationStatus.textContent = locationStatusText;
            locationStatus.className = `status-badge ${locationStatusClass}`;
            
            // Show coordinates if available
            if (detectionState.location) {
                coordinates.textContent = `Coordinates: ${detectionState.location.latitude.toFixed(6)}, ${detectionState.location.longitude.toFixed(6)} (¬±${Math.round(detectionState.location.accuracy)}m)`;
            }
            
            // Analyze environment
            let environmentScore = 100;
            let environmentStatusText = 'Local Desktop';
            let environmentStatusClass = 'status-authentic';
            
            detectionState.environmentFlags.forEach(flag => {
                const item = document.createElement('div');
                item.className = 'detection-item';
                
                // Create main message with indicator
                const mainLine = document.createElement('div');
                mainLine.innerHTML = `<span class="indicator ${flag.type}"></span>${flag.message}`;
                item.appendChild(mainLine);
                
                // Add explanation if available
                if (flag.explanation) {
                    const explanation = document.createElement('div');
                    explanation.className = 'detection-explanation';
                    explanation.textContent = flag.explanation;
                    item.appendChild(explanation);
                }
                
                environmentDetails.appendChild(item);
                
                if (flag.type === 'warning') environmentScore -= thresholds.scoring.deductions.environmentWarning;
                if (flag.type === 'fail') environmentScore -= thresholds.scoring.deductions.environmentFail;
            });
            
            if (environmentScore < thresholds.environment.score.likelyRemote) {
                environmentStatusText = 'Remote Desktop';
                environmentStatusClass = 'status-spoofed';
            } else if (environmentScore < thresholds.environment.score.possiblyRemote) {
                environmentStatusText = 'Possibly Remote';
                environmentStatusClass = 'status-suspicious';
            }
            
            environmentStatus.textContent = environmentStatusText;
            environmentStatus.className = `status-badge ${environmentStatusClass}`;
            
            // Add summary items if no issues found
            if (detectionState.locationFlags.length === 0) {
                const item = document.createElement('div');
                item.className = 'detection-item';
                
                const mainLine = document.createElement('div');
                mainLine.innerHTML = '<span class="indicator pass"></span>All location checks passed';
                item.appendChild(mainLine);
                
                const explanation = document.createElement('div');
                explanation.className = 'detection-explanation';
                explanation.textContent = 'No indicators of location spoofing were detected. GPS coordinates appear genuine.';
                item.appendChild(explanation);
                
                locationDetails.appendChild(item);
            }
            
            if (detectionState.environmentFlags.length === 0) {
                const item = document.createElement('div');
                item.className = 'detection-item';
                
                const mainLine = document.createElement('div');
                mainLine.innerHTML = '<span class="indicator pass"></span>No remote environment indicators';
                item.appendChild(mainLine);
                
                const explanation = document.createElement('div');
                explanation.className = 'detection-explanation';
                explanation.textContent = 'Display characteristics match a physical device. No signs of remote desktop or virtual machine usage.';
                item.appendChild(explanation);
                
                environmentDetails.appendChild(item);
            }
        }

        // Make function available globally for API integration
        window.analyzeResults = analyzeResults;

        // Run rule-based checks on session data
        function runRulesCheck() {
            if (!sessionData) {
                console.log('No session data available for rules check');
                return;
            }
            
            // Show the rules check card
            const rulesCard = document.getElementById('rulesCheckCard');
            if (rulesCard) {
                rulesCard.style.display = 'block';
            }
            
            // Run the checks
            const checkResults = window.SessionRulesCheck.runAllChecks({
                multiDetectionSession: sessionData,
                currentSession: sessionData
            });
            
            // Update status badge
            const statusEl = document.getElementById('rulesCheckStatus');
            if (checkResults.hasIssues) {
                statusEl.textContent = `${checkResults.summary.failedChecks} Issues Found`;
                statusEl.className = 'status-badge status-spoofed';
            } else {
                statusEl.textContent = 'All Checks Passed';
                statusEl.className = 'status-badge status-authentic';
            }
            
            // Display results
            const contentEl = document.getElementById('rulesCheckContent');
            let html = '<div class="rules-check-results">';
            
            // Summary
            html += '<h4 style="margin-bottom: 15px;">üìä Check Summary</h4>';
            html += `<p><strong>Total Checks:</strong> ${checkResults.summary.totalChecks}</p>`;
            html += `<p><strong>Passed:</strong> <span style="color: #34d399;">${checkResults.summary.passedChecks}</span></p>`;
            html += `<p><strong>Failed:</strong> <span style="color: #ef4444;">${checkResults.summary.failedChecks}</span></p>`;
            
            // Failed checks details
            if (checkResults.errorMessages.length > 0) {
                html += '<h4 style="margin-top: 20px; margin-bottom: 15px;">‚ö†Ô∏è Issues Detected</h4>';
                html += '<ul style="margin-left: 20px;">';
                checkResults.errorMessages.forEach(message => {
                    html += `<li class="detection-item"><span class="indicator fail"></span>${message}</li>`;
                });
                html += '</ul>';
            }
            
            // Individual check results
            html += '<h4 style="margin-top: 20px; margin-bottom: 15px;">üìã Individual Check Results</h4>';
            html += '<div style="display: grid; gap: 10px;">';
            
            checkResults.results.forEach(result => {
                const statusClass = result.result ? 'fail' : 'pass';
                const statusIcon = result.result ? '‚úó' : '‚úì';
                const bgColor = result.result ? 'rgba(239, 68, 68, 0.1)' : 'rgba(52, 211, 153, 0.1)';
                
                html += `<div style="background: ${bgColor}; padding: 10px; border-radius: 8px; display: flex; align-items: center; gap: 10px;">`;
                html += `<span class="check-status ${statusClass}">${statusIcon}</span>`;
                html += `<span style="flex: 1;">${formatCheckName(result.checkName)}</span>`;
                if (result.message && result.result) {
                    html += `<span style="font-size: 0.85em; opacity: 0.8;">${result.message}</span>`;
                }
                html += '</div>';
            });
            
            html += '</div>';
            html += '</div>';
            
            contentEl.innerHTML = html;
        }
        
        // Helper function to format check names
        function formatCheckName(name) {
            // Convert camelCase to readable format
            return name
                .replace(/([A-Z])/g, ' $1')
                .replace(/^check /, '')
                .replace(/^./, str => str.toUpperCase())
                .trim();
        }

        // Button ripple effect
        document.getElementById('locateBtn').addEventListener('click', function(e) {
            const ripple = document.createElement('span');
            ripple.className = 'ripple';
            const size = 40;
            ripple.style.width = ripple.style.height = size + 'px';
            ripple.style.left = (e.offsetX - size / 2) + 'px';
            ripple.style.top = (e.offsetY - size / 2) + 'px';
            this.appendChild(ripple);
            setTimeout(() => ripple.remove(), 600);
        });

        // Add click handler for the main detection function
        document.getElementById('locateBtn').addEventListener('click', startDetection);
        
        // Setup pattern analysis functionality
        window.showPatternAnalysis = false;
        
        // Show pattern analysis card after detection completes
        window.showPatternAnalysisCard = function() {
            const card = document.getElementById('patternAnalysisCard');
            if (card) {
                card.style.display = 'block';
            }
        };
        
        // Pattern analysis UI function
        window.showPatternAnalysisUI = function(evaluation, similarSessions) {
            const contentEl = document.getElementById('patternAnalysisContent');
            if (!contentEl) return;
            
            let html = '<div class="pattern-analysis-results">';
            
            // Show evaluation summary
            if (evaluation.riskAssessment || evaluation.analysis) {
                html += '<div class="analysis-section">';
                html += '<h4 style="margin-bottom: 10px;">ü§ñ AI Analysis</h4>';
                
                if (evaluation.riskAssessment) {
                    html += `<p><strong>Risk Level:</strong> <span class="status-badge ${getRiskClass(evaluation.riskAssessment)}">${evaluation.riskAssessment}</span></p>`;
                }
                
                if (evaluation.confidence) {
                    html += `<p><strong>Confidence:</strong> ${evaluation.confidence}%</p>`;
                }
                
                if (evaluation.riskScore !== undefined) {
                    html += `<p><strong>Risk Score:</strong> ${evaluation.riskScore}/100</p>`;
                }
                
                if (evaluation.processingTime) {
                    html += `<p style="font-size: 0.85em; opacity: 0.7;">Processing time: ${evaluation.processingTime}</p>`;
                }
                
                if (evaluation.explanation) {
                    html += `<p style="margin: 10px 0;">${evaluation.explanation}</p>`;
                }
                
                if (evaluation.riskFactors && evaluation.riskFactors.length > 0) {
                    html += '<p><strong>Risk Factors:</strong></p>';
                    html += '<ul style="margin-left: 20px;">';
                    evaluation.riskFactors.forEach(factor => {
                        html += `<li>${factor}</li>`;
                    });
                    html += '</ul>';
                }
                
                if (evaluation.patterns && evaluation.patterns.length > 0) {
                    html += '<p><strong>Patterns Detected:</strong></p>';
                    html += '<ul style="margin-left: 20px;">';
                    evaluation.patterns.forEach(pattern => {
                        html += `<li>${pattern}</li>`;
                    });
                    html += '</ul>';
                }
                
                if (evaluation.technicalIndicators) {
                    html += '<p><strong>Technical Indicators:</strong></p>';
                    if (evaluation.technicalIndicators.location && evaluation.technicalIndicators.location.length > 0) {
                        html += '<p style="margin-left: 20px;"><em>Location:</em></p>';
                        html += '<ul style="margin-left: 40px;">';
                        evaluation.technicalIndicators.location.forEach(indicator => {
                            html += `<li>${indicator}</li>`;
                        });
                        html += '</ul>';
                    }
                    if (evaluation.technicalIndicators.environment && evaluation.technicalIndicators.environment.length > 0) {
                        html += '<p style="margin-left: 20px;"><em>Environment:</em></p>';
                        html += '<ul style="margin-left: 40px;">';
                        evaluation.technicalIndicators.environment.forEach(indicator => {
                            html += `<li>${indicator}</li>`;
                        });
                        html += '</ul>';
                    }
                    if (evaluation.technicalIndicators.network && evaluation.technicalIndicators.network.length > 0) {
                        html += '<p style="margin-left: 20px;"><em>Network:</em></p>';
                        html += '<ul style="margin-left: 40px;">';
                        evaluation.technicalIndicators.network.forEach(indicator => {
                            html += `<li>${indicator}</li>`;
                        });
                        html += '</ul>';
                    }
                }
                
                if (evaluation.spoofingTechniques && evaluation.spoofingTechniques.length > 0) {
                    html += '<p><strong>Spoofing Techniques Detected:</strong></p>';
                    html += '<ul style="margin-left: 20px;">';
                    evaluation.spoofingTechniques.forEach(technique => {
                        html += `<li>${technique}</li>`;
                    });
                    html += '</ul>';
                }
                
                if (evaluation.recommendations && evaluation.recommendations.length > 0) {
                    html += '<p><strong>Recommendations:</strong></p>';
                    html += '<ul style="margin-left: 20px;">';
                    evaluation.recommendations.forEach(rec => {
                        html += `<li>${rec}</li>`;
                    });
                    html += '</ul>';
                }
                
                if (evaluation.similarityInsights) {
                    html += `<p><strong>Similar Sessions:</strong> ${evaluation.similarityInsights}</p>`;
                }
                
                html += '</div>';
            }
            
            // Show similar sessions
            if (similarSessions && similarSessions.length > 0) {
                html += '<div class="analysis-section" style="margin-top: 20px;">';
                html += '<h4 style="margin-bottom: 10px;">üìä Similar Sessions Found</h4>';
                
                similarSessions.forEach((session, idx) => {
                    const payload = session.payload || session;
                    html += `<div class="similar-session" style="background: rgba(255,255,255,0.05); padding: 10px; margin: 10px 0; border-radius: 8px;">`;
                    html += `<p><strong>Session ${idx + 1}</strong> - Similarity: ${(session.score * 100).toFixed(1)}%</p>`;
                    html += `<p style="font-size: 0.85em; opacity: 0.8;">Risk: ${payload.summary?.overallRisk || session.risk || 'Unknown'}</p>`;
                    
                    const indicators = payload.summary?.spoofingIndicators || session.indicators || [];
                    if (indicators.length > 0) {
                        html += `<p style="font-size: 0.85em; opacity: 0.8;">Indicators: ${indicators.join(', ')}</p>`;
                    }
                    
                    html += '</div>';
                });
                
                html += '</div>';
            }
            
            html += '</div>';
            
            contentEl.innerHTML = html;
        };
        
        function getRiskClass(risk) {
            switch(risk?.toLowerCase()) {
                case 'high': return 'status-spoofed';
                case 'medium': return 'status-suspicious';
                case 'low': return 'status-authentic';
                default: return 'status-suspicious';
            }
        }
        
        // Pattern analysis button handler
        const patternAnalysisBtn = document.getElementById('runPatternAnalysis');
        if (patternAnalysisBtn) {
            patternAnalysisBtn.addEventListener('click', async function() {
                this.disabled = true;
                this.textContent = 'Analyzing...';
                
                try {
                    // Prepare session data
                    const sessionData = {
                        location: window.detectionState.location,
                        environment: {
                            screenResolution: {
                                width: window.screen.width,
                                height: window.screen.height
                            },
                            colorDepth: window.screen.colorDepth,
                            touchSupport: 'ontouchstart' in window,
                            timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                            language: navigator.language,
                            platform: navigator.platform
                        },
                        detectionResults: {
                            locationScore: calculateLocationScore(),
                            environmentScore: calculateEnvironmentScore(),
                            locationFlags: window.detectionState.locationFlags,
                            environmentFlags: window.detectionState.environmentFlags
                        }
                    };
                    
                    // Find similar sessions
                    const response = await fetch('/api/session/similar', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ sessionData, limit: 5 })
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        
                        // Get AI evaluation
                        const evalResponse = await fetch('/api/session/evaluate', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                currentSession: sessionData,
                                similarSessions: result.similarSessions
                            })
                        });
                        
                        if (evalResponse.ok) {
                            const evalResult = await evalResponse.json();
                            window.showPatternAnalysisUI(evalResult.evaluation, result.similarSessions);
                        }
                    }
                } catch (error) {
                    console.error('Pattern analysis error:', error);
                    document.getElementById('patternAnalysisContent').innerHTML = 
                        '<p style="color: #ef4444;">Error running pattern analysis. Make sure Gemini API key and Qdrant are configured.</p>';
                } finally {
                    this.disabled = false;
                    this.textContent = 'Full Analysis';
                }
            });
        }
        
        // Lite analysis button handler
        const liteAnalysisBtn = document.getElementById('runLiteAnalysis');
        if (liteAnalysisBtn) {
            liteAnalysisBtn.addEventListener('click', async function() {
                this.disabled = true;
                this.textContent = 'Analyzing...';
                
                try {
                    // Prepare session data
                    const sessionData = {
                        location: window.detectionState.location,
                        environment: {
                            screenResolution: {
                                width: window.screen.width,
                                height: window.screen.height
                            },
                            colorDepth: window.screen.colorDepth,
                            touchSupport: 'ontouchstart' in window,
                            webglRenderer: await getWebGLRenderer(),
                            timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                            language: navigator.language,
                            platform: navigator.platform
                        },
                        detectionResults: {
                            locationScore: calculateLocationScore(),
                            environmentScore: calculateEnvironmentScore(),
                            locationFlags: window.detectionState.locationFlags,
                            environmentFlags: window.detectionState.environmentFlags
                        }
                    };
                    
                    // Call lite analysis endpoint
                    const response = await fetch('/api/session/analyze-lite', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ sessionData })
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        window.showPatternAnalysisUI(result.evaluation, result.similarSessions);
                    } else {
                        throw new Error('Failed to perform lite analysis');
                    }
                } catch (error) {
                    console.error('Lite analysis error:', error);
                    document.getElementById('patternAnalysisContent').innerHTML = 
                        '<p style="color: #ef4444;">Error running lite analysis. Please try again.</p>';
                } finally {
                    this.disabled = false;
                    this.textContent = 'Lite Analysis';
                }
            });
        }
        
        // Helper function to get WebGL renderer info
        async function getWebGLRenderer() {
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                if (gl) {
                    const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                    if (debugInfo) {
                        return gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                    }
                }
            } catch (e) {}
            return 'Unknown';
        }
        
        // Helper function to calculate scores
        function calculateLocationScore() {
            let score = 100;
            if (window.detectionState.locationFlags) {
                window.detectionState.locationFlags.forEach(flag => {
                    if (flag.type === 'warning') score -= 20;
                    if (flag.type === 'fail') score -= 40;
                });
            }
            return Math.max(0, score);
        }
        
        function calculateEnvironmentScore() {
            let score = 100;
            if (window.detectionState.environmentFlags) {
                window.detectionState.environmentFlags.forEach(flag => {
                    if (flag.type === 'warning') score -= 25;
                    if (flag.type === 'fail') score -= 50;
                });
            }
            return Math.max(0, score);
        }
        
        // Update startDetection to show pattern analysis card
        const originalStartDetection = startDetection;
        startDetection = async function() {
            await originalStartDetection();
            // Show pattern analysis card after detection
            window.showPatternAnalysisCard();
        };
        
        // Setup collapse/expand functionality for check categories
        function setupCategoryCollapse() {
            const categories = document.querySelectorAll('.check-category');
            
            categories.forEach(category => {
                const header = category.querySelector('h4');
                const categoryId = category.id;
                
                // Load saved collapse state from localStorage
                const savedState = localStorage.getItem(`category-${categoryId}`);
                if (savedState === 'collapsed') {
                    category.classList.add('collapsed');
                }
                
                header.addEventListener('click', () => {
                    category.classList.toggle('collapsed');
                    
                    // Save state to localStorage
                    if (category.classList.contains('collapsed')) {
                        localStorage.setItem(`category-${categoryId}`, 'collapsed');
                    } else {
                        localStorage.removeItem(`category-${categoryId}`);
                    }
                });
            });
            
            // Toggle all button functionality
            const toggleAllBtn = document.getElementById('toggleAllCategories');
            if (toggleAllBtn) {
                toggleAllBtn.addEventListener('click', () => {
                    const allCollapsed = Array.from(categories).every(cat => cat.classList.contains('collapsed'));
                    
                    categories.forEach(category => {
                        if (allCollapsed) {
                            // Expand all
                            category.classList.remove('collapsed');
                            localStorage.removeItem(`category-${category.id}`);
                        } else {
                            // Collapse all
                            category.classList.add('collapsed');
                            localStorage.setItem(`category-${category.id}`, 'collapsed');
                        }
                    });
                    
                    // Update button text
                    toggleAllBtn.textContent = allCollapsed ? 'Collapse All' : 'Expand All';
                });
                
                // Set initial button text based on current state
                const allCollapsed = Array.from(categories).every(cat => cat.classList.contains('collapsed'));
                toggleAllBtn.textContent = allCollapsed ? 'Expand All' : 'Collapse All';
            }
        }
        
        // Initialize collapse functionality after DOM is loaded
        setupCategoryCollapse();
        
        console.log('Main script finished loading');
        console.log('Functions available:', {
            detectLocation: typeof detectLocation,
            detectEnvironment: typeof detectEnvironment,
            analyzeResults: typeof analyzeResults
        });
        
        // Re-run API integration setup now that all functions are available
        if (typeof setupAPIIntegration === 'function' && typeof USE_API !== 'undefined' && USE_API) {
            console.log('Re-running API integration setup with all functions available');
            setupAPIIntegration();
        }

        // Initialize detection when page loads
        window.addEventListener('DOMContentLoaded', async () => {
            // Load thresholds configuration
            await window.ThresholdsConfig.loadThresholds();
            console.log('Thresholds loaded:', window.ThresholdsConfig.getThresholdsSync());
            
            // Initialize all checks
            renderChecks();
            
            // Make functions globally available for API integration
            window.detectLocation = detectLocation;
            window.detectEnvironment = detectEnvironment;
            window.analyzeResults = analyzeResults;
        });
        
        // Example usage for developers (available in console)
        console.log(`
=== Geo Spoofer Detector - Developer Examples ===

// NEW: Session-based detection (multiple detections in one session)
// Start a session
const sessionId = window.DetectionRunner.startSession({ purpose: 'testing' });

// Run detections in the session
await window.DetectionRunner.runDetectionInSession();
await window.DetectionRunner.runDetectionInSession();

// End session and get complete data
const session = window.DetectionRunner.endSession();
console.log('Session with', session.detections.length, 'detections');

// Store the session
await window.DetectionRunner.storeSession(session);

// OR: Run multiple detections in one call
const multiSession = await window.DetectionRunner.runSessionWithMultipleDetections(
    3,     // Run 3 detections
    1000,  // 1 second delay between each
    {
        includeLocation: true,
        includeEnvironment: true,
        includeNetwork: true,
        metadata: { purpose: 'consistency-check' }
    }
);

// Store multi-detection session
await window.DetectionRunner.storeSession(multiSession);

// Access last sessions:
console.log(window.lastDetectionSession);         // Single detection
console.log(window.lastMultiDetectionSession);    // Multi-detection session
console.log(window.lastStoredSessionId);          // Last stored session ID

// Export all sessions:
document.getElementById('exportSessionBtn').click();
        `);

        // Store last session for export
        window.lastDetectionSession = null;
        window.multiDetectionResults = null;
        
        // Update startDetection to use DetectionRunner
        const startDetectionWithRunner = async function() {
            const btn = document.getElementById('locateBtn');
            const btnText = document.getElementById('btnText');
            const progressBar = document.getElementById('progressBar');
            const progressFill = document.getElementById('progressFill');
            const results = document.getElementById('results');
            
            // Update UI
            btn.classList.add('scanning');
            btnText.textContent = 'üîÑ Scanning...';
            progressBar.style.display = 'block';
            results.style.display = 'block';
            
            // Reset global state for UI
            window.detectionState = {
                location: null,
                timestamps: [],
                permissions: {},
                environmentFlags: [],
                locationFlags: []
            };
            
            // Run detection using DetectionRunner
            await updateProgress(10);
            
            const session = await window.DetectionRunner.runDetection({
                includeLocation: true,
                includeEnvironment: true,
                includeNetwork: true,
                silent: false
            });
            
            await updateProgress(90);
            
            // Update global state from session for UI compatibility
            window.detectionState = {
                location: session.location,
                timestamps: session.timestamps,
                permissions: {},
                environmentFlags: session.environmentFlags,
                locationFlags: session.locationFlags
            };
            
            // Update checks UI
            Object.keys(session.checks).forEach(category => {
                session.checks[category].forEach(check => {
                    updateCheck(category, check.id, check.status, check.result);
                });
            });
            
            await updateProgress(100);
            
            // Analyze results
            analyzeResults();
            
            // Store session
            window.lastDetectionSession = session;
            document.getElementById('exportSessionBtn').style.display = 'block';
            
            // Show results
            setTimeout(() => {
                btn.classList.remove('scanning');
                btnText.textContent = 'üîç Locate Me';
                progressBar.style.display = 'none';
                progressFill.style.width = '0%';
            }, 500);
            
            // Show pattern analysis card
            window.showPatternAnalysisCard();
            
            // Store session if API is available
            if (typeof storeSessionFingerprint === 'function') {
                storeSessionFingerprint();
            }
        };
        
        // Handle multiple detection button
        document.getElementById('multiDetectBtn').addEventListener('click', async function() {
            const btn = this;
            const btnText = document.getElementById('multiDetectBtnText');
            const progressBar = document.getElementById('progressBar');
            const progressFill = document.getElementById('progressFill');
            const results = document.getElementById('results');
            const multiResults = document.getElementById('multiDetectionResults');
            
            // Update UI
            btn.classList.add('scanning');
            btnText.textContent = 'üîÑ Running Multiple Detections...';
            progressBar.style.display = 'block';
            results.style.display = 'block';
            
            // Run multiple detections in a single session
            const detectionCount = 3;
            const delay = 1500; // 1.5 seconds between runs
            
            // Update progress during detections
            let progressInterval = setInterval(() => {
                const currentProgress = parseInt(progressFill.style.width) || 0;
                if (currentProgress < 90) {
                    updateProgress(currentProgress + 10);
                }
            }, 500);
            
            try {
                // Run session with multiple detections
                const session = await window.DetectionRunner.runSessionWithMultipleDetections(
                    detectionCount, 
                    delay, 
                    {
                        includeLocation: true,
                        includeEnvironment: true,
                        includeNetwork: true,
                        silent: false,
                        metadata: {
                            purpose: 'multi-detection-consistency-check',
                            userAgent: navigator.userAgent
                        }
                    }
                );
                console.log('session', session);
                
                clearInterval(progressInterval);
                await updateProgress(100);
                
                // Store results
                window.lastMultiDetectionSession = session;
                window.multiDetectionResults = session; // For backward compatibility
                document.getElementById('exportSessionBtn').style.display = 'block';
                
                // Store session if API is available
                if (typeof storeSessionWithDetections === 'function' && session.detections.length > 0) {
                    const storeResult = await storeSessionWithDetections(session);
                    
                    if (storeResult) {
                        window.lastStoredSessionId = storeResult.sessionId;
                    }
                }
                
                // Display multi-detection analysis
                displayMultiDetectionSession(session);
                multiResults.style.display = 'block';
                
            } catch (error) {
                console.error('Multi-detection error:', error);
                clearInterval(progressInterval);
                await updateProgress(100);
                
                // Show error in UI
                const detailsEl = document.getElementById('multiDetectionDetails');
                detailsEl.innerHTML = `<p style="color: #ef4444;">Error running multiple detections: ${error.message}</p>`;
                multiResults.style.display = 'block';
            }
            
            // Reset UI
            setTimeout(() => {
                btn.classList.remove('scanning');
                btnText.textContent = 'üîÑ Run Multiple Detections (3x)';
                progressBar.style.display = 'none';
                progressFill.style.width = '0%';
            }, 500);
        });
        
        // Display multiple detection session results
        function displayMultiDetectionSession(session) {
            const detailsEl = document.getElementById('multiDetectionDetails');
            const statusEl = document.getElementById('consistencyStatus');
            
            const { summary, detections } = session;
            
            // Set overall status
            if (summary.consistency.inconsistencies.length > 0) {
                statusEl.textContent = 'Inconsistent';
                statusEl.className = 'status-badge status-spoofed';
            } else if (summary.consistency.scoreVariance > 5) {
                statusEl.textContent = 'Unstable';
                statusEl.className = 'status-badge status-suspicious';
            } else {
                statusEl.textContent = 'Consistent';
                statusEl.className = 'status-badge status-authentic';
            }
            
            // Build details HTML
            let html = '<div class="multi-detection-summary">';
            
            // Session info
            html += '<h4 style="margin-bottom: 15px;">üìã Session Information</h4>';
            html += `<p><strong>Session ID:</strong> ${session.sessionId}</p>`;
            html += `<p><strong>Duration:</strong> ${(summary.timespan.durationMs / 1000).toFixed(1)}s</p>`;
            
            // Summary section
            html += '<h4 style="margin-top: 20px; margin-bottom: 15px;">üìä Summary</h4>';
            html += `<p><strong>Total Detections:</strong> ${summary.detectionCount}</p>`;
            html += '<p><strong>Average Scores:</strong></p>';
            html += '<ul style="margin-left: 20px;">';
            html += `<li>Location: ${summary.averageScores.location}%</li>`;
            html += `<li>Environment: ${summary.averageScores.environment}%</li>`;
            html += `<li>Network: ${summary.averageScores.network}%</li>`;
            html += `<li>Overall: ${summary.averageScores.overall}%</li>`;
            html += '</ul>';
            
            // Consistency section
            html += '<h4 style="margin-top: 20px; margin-bottom: 15px;">üîç Consistency Analysis</h4>';
            html += '<ul style="margin-left: 20px;">';
            html += `<li>Location Consistency: <span class="${summary.consistency.location ? 'status-authentic' : 'status-spoofed'}">${summary.consistency.location ? 'Consistent' : 'Inconsistent'}</span></li>`;
            html += `<li>Environment Consistency: <span class="${summary.consistency.environment ? 'status-authentic' : 'status-spoofed'}">${summary.consistency.environment ? 'Consistent' : 'Inconsistent'}</span></li>`;
            html += `<li>Score Stability: <span class="${summary.consistency.scoreVariance < 5 ? 'status-authentic' : 'status-suspicious'}">Variance: ${summary.consistency.scoreVariance.toFixed(2)}</span></li>`;
            html += '</ul>';
            
            // Inconsistencies
            if (summary.consistency.inconsistencies.length > 0) {
                html += '<h4 style="margin-top: 20px; margin-bottom: 15px;">‚ö†Ô∏è Inconsistencies Detected</h4>';
                html += '<ul style="margin-left: 20px;">';
                summary.consistency.inconsistencies.forEach(inc => {
                    html += `<li class="detection-item"><span class="indicator warning"></span>${inc.message}</li>`;
                });
                html += '</ul>';
            }
            
            // Individual detection results
            html += '<h4 style="margin-top: 20px; margin-bottom: 15px;">üìã Individual Detections</h4>';
            detections.forEach((detection, idx) => {
                html += `<div style="background: rgba(255,255,255,0.05); padding: 10px; margin: 10px 0; border-radius: 8px;">`;
                html += `<p><strong>Detection ${detection.detectionIndex + 1}</strong> (${detection.detectionTimestamp})</p>`;
                html += `<p style="font-size: 0.9em;">Scores: Location ${detection.scores.location}%, Environment ${detection.scores.environment}%, Network ${detection.scores.network}%</p>`;
                
                if (detection.location) {
                    html += `<p style="font-size: 0.9em;">Location: ${detection.location.latitude.toFixed(6)}, ${detection.location.longitude.toFixed(6)} (¬±${Math.round(detection.location.accuracy)}m)</p>`;
                    html += `<p style="font-size: 0.9em;">Response Time: ${detection.location.responseTime.toFixed(0)}ms</p>`;
                }
                
                html += `<p style="font-size: 0.9em;">Fingerprint: ${detection.fingerprint}</p>`;
                html += '</div>';
            });
            
            html += '</div>';
            
            detailsEl.innerHTML = html;
        }
        
        // Export sessions
        document.getElementById('exportSessionBtn').addEventListener('click', function() {
            const exportData = {
                timestamp: new Date().toISOString(),
                currentSession: sessionData,  // Add current session data
                singleSession: window.lastDetectionSession,
                multiDetectionSession: window.lastMultiDetectionSession,
                // Legacy format for backward compatibility
                multipleDetections: window.multiDetectionResults
            };
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `geo-detection-sessions-${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        // Override startDetection with the new runner version
        startDetection = startDetectionWithRunner;
    </script>
</body>
</html>